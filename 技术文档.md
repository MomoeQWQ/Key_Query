## **技术文档：隐私保护的时空关键词检索系统 (Project "Guardian Maps")**

### 1. 项目愿景与目标

 **1.1 愿景**
创建一个功能类似于主流地图应用（如 Google Maps）的地点检索引擎，但其核心是**隐私保护**。用户可以执行“时空关键词”查询（例如，“在我附近的意大利餐厅”），而服务器无法得知用户的确切位置、查询的关键词或最终的检索结果。

 **1.2 核心目标**

* **功能对标**: 实现基本的时空关键词检索，用户输入文本和（可选的）位置，系统返回匹配的地点列表。
* **隐私保证**:

  * **查询隐私**: 服务器无法从用户的请求中学习到查询的具体内容（关键词、位置）。
* **数据隐私**: 服务器存储的数据（地点信息）是经过加密的，无法直接读取。
* **访问模式隐私**: 理论上，服务器无法轻易判断哪些数据记录被访问了。
* **架构**: 采用 Client/Server 架构，清晰划分客户端（Web浏览器）、客户端代理后端和多个独立的、非共谋的云服务器。
* **交互性**: 提供一个带有地图的可视化Web界面，用户可以在地图上看到查询结果。

### 2. 系统架构

  **本系统采用三层架构：**数据所有者（离线）**、**云端服务（在线） **和** **客户端（在线）**。

  **2.1 数据所有者 (Data Owner)**

* **角色**: 负责数据的初始化和加密。这是一个**一次性、离线**的过程。
* **职责**:

  * **数据采集**: 通过API（如 OpenStreetMap, Foursquare API）或从数据库获取原始的地理位置数据（ID, 经纬度, 描述/关键词）。
* **执行Setup过程**: 运行您项目中的 **SetupProcess.py**。
* **生成产物**:

  * **认证索引 (AUI)**: 加密的、可供检索的索引。

    ***秘密密钥 (K)**: **K = (Ke, Kv, Kh)**，用于客户端解密和验证。

* **分发**:

  * **将**AUI**安全地部署到**U**个云服务器上。**
    * **将**秘密密钥 K **安全地分发给客户端代理后端。**

**2.2 云端服务 (Secure Cloud Parties)**

* **角色**: **U**个（例如，3个）独立的、互不信任的服务器。它们存储加密索引并执行分布式计算。
* **职责**:

  * **存储**: 持有数据所有者分发的认证索引 (AUI)。
* **计算**: 接收来自客户端的**密钥份额 (Key Share)**，并利用这些份额和本地的AUI执行 **server_side_computation**。
* **响应**: 将计算出的**结果份额 (Result Share)** **返回给客户端。**
* **API**: 提供一个唯一的API端点 **/search**。

**2.3 客户端 (Client)**
客户端分为两部分，以提升安全性和用户体验：

* **2.3.1 前端应用 (Web Browser)**

  * **角色**: 用户交互界面。
  * **技术栈**: React / Vue / Svelte + 地图库 (Leaflet.js / Mapbox GL JS)。
  * **职责**:

    * **渲染地图和UI组件（搜索框、按钮）。**
  * **获取用户输入的查询关键词和地理位置（可通过浏览器 Geolocation API 或地图中心点获取）。**
  * **将查询请求发送给**客户端代理后端**。**
  * **接收来自代理后端的明文结果，并在地图上渲染标记点。**
* **2.3.2 客户端代理后端 (Backend-for-Frontend)**

  * **角色**: 处理所有复杂的密码学操作，保护密钥不暴露在浏览器中。
  * **技术栈**: Python (Flask / FastAPI)。
  * **职责**:

    * **持有秘密密钥 K**。
  * **接收前端发来的明文查询** **Q**。
  * **生成查询陷门**:

    * **编码查询:** **encode_query(Q)** **->** **BQ**。
      * **生成密钥份额: 对**BQ**中的每个块调用** **DMPF.Gen()** **->** **(share_1, share_2, ..., share_U)**。
  * **与云端服务交互**: 将每个**share_l**分别发送给对应的云服务器**l**。
  * **聚合与解密**:

    * **收集所有云服务器返回的结果份额。**
      * **组合份额:** **combine_results()**。
      * **解密结果:** **decrypt_all_results()**。
  * **返回明文结果**: 将最终匹配的地点列表（ID, 坐标, 关键词）返回给前端应用。

### 3. 核心算法与数据流

**3.1 工作流程**

* **(离线) Setup阶段**

  * **数据所有者获取地点数据。**
  * **运行** **Setup**，生成 **AUI** **和** **K**。
  * **将** **AUI** **部署到3个云服务器。**
  * **将** **K** **和原始数据（用于最终结果映射）部署到客户端代理后端。**
* **(在线) 查询阶段**

  * **用户**: 在Web界面输入 "pizza"，地图中心点为 (40.71, -74.00)。
  * **前端**: 发送 **POST /api/query** **请求到客户端代理后端，Body:** **{ "keywords": "pizza", "location": { "lat": 40.71, "lon": -74.00 } }**。
  * **客户端代理后端**:

    * **将查询** **Q** **构造为** **(40.71,-74.00) pizza**。
  * **调用** **encode_query** **和** **DMPF.Gen**，为查询 **Q** **生成3组密钥份额。**
  * **并发地向3个云服务器的** **/search** **端点发送各自的密钥份额。**
  * **云端服务器 (x3)**:

    * **收到密钥份额。**
  * **执行** **server_side_computation**，计算出自己的结果份额。
  * **将结果份额返回给客户端代理后端。**
  * **客户端代理后端**:

    * **等待并收集所有3个结果份额。**
  * **调用** **combine_results** **(XOR操作)。**
  * **调用** **decrypt_all_results**，使用 **Ke** **解密，得到明文内积值。**
  * **根据内积值与预期的指纹值比较，筛选出匹配的记录ID。**
  * **根据ID查询原始数据库，获取地点详情。**
  * **将匹配的地点列表** **[{id, name, location...}]** **返回给前端。**
  * **前端**:

    * **收到地点列表。**
  * **在地图上渲染这些地点的标记。**

### 4. API 规范 (初版)

**4.1 云端服务器 API**

* **Endpoint**: **POST /search**
* **Request Body**:

  **code**JSON

```
  {
    "keys": {
      "b_R1": { "seed": "..." },
      "b_W_star": { "seed": "..." }
    }
  }
```

* **Response Body**:

  **code**JSON

```
  {
    "result_share": ["<big_integer_string_1>", "<big_integer_string_2>"]
  }
```

**4.2 客户端代理后端 API**

* **Endpoint**: **POST /api/query**
* **Request Body**:

  **code**JSON

```
  {
    "keywords": "italian food",
    "location": {
      "lat": 40.7128,
      "lon": -74.0060
    }
  }
```

* **Response Body**:

  **code**JSON

```
  {
    "results": [
      {
        "id": "12345",
        "name": "Luigi's Pizza",
        "location": { "lat": 40.7130, "lon": -74.0055 },
        "keywords": "Luigi's Pizza 123 Canal St New York NY"
      }
    ]
  }
```

### 5. 技术栈选型

* **前端**: React + Leaflet.js (开源) / Mapbox GL JS (提供更丰富的底图)。
* **客户端代理后端**: Python + FastAPI (高性能) 或 Flask (简洁)。
* **云端服务器**: Python + FastAPI / Flask。
* **数据源**:

  * **初始化**: OpenStreetMap API (通过 Overpass API) / Foursquare API。
* **部署**: 将采集的数据存入一个简单的数据库（如 PostgreSQL + PostGIS 用于地理查询）或文件中，供数据所有者和客户端代理后端使用。
* **部署**: Docker + Docker Compose 用于本地开发和模拟多服务器环境。云端可部署到 AWS/GCP/Azure 的多个独立虚拟机或容器服务上。

### 6. 实施路线图 (Roadmap)

* **阶段一: 后端核心功能实现 (2-3周)**

  * **完成** **Setup** **脚本，使其能从真实数据源生成** **AUI** **和** **K** **并保存为文件。**
  * **实现云服务器的** **server.py**，加载 **AUI** **并提供** **/search** **API。**
  * **实现客户端代理后端的** **client_backend.py**，加载 **K**，实现陷门生成、与云服务器通信、结果聚合解密的全流程。
  * **使用** **curl** **或 Postman 进行端到端测试。**
* **阶段二: 基础前端与集成 (2周)**

  * **搭建 React/Vue 项目。**
  * **集成地图库，实现基本地图显示。**
  * **创建搜索框，将用户输入发送到客户端代理后端的** **/api/query**。
  * **接收结果，并在控制台打印。**
* **阶段三: 可视化与交互增强 (1-2周)**

  * **在地图上将返回结果渲染为标记点 (Markers)。**
  * **实现点击标记点显示地点详情的弹出框。**
  * **添加加载状态、错误处理等UI优化。**
  * **实现通过拖动地图更新位置并发起新查询。**
* **阶段四: 部署与安全加固 (1周)**

  * **编写 Dockerfile 和** **docker-compose.yml**，一键启动整个系统（3个云服务器 + 1个代理后端 + 1个前端服务）。
  * **配置 HTTPS/TLS 加密所有网络通信。**
  * **进行初步的性能测试和安全审查。**
